
utilities:
  <<: (( &temporary(merge || ~) ))

  certs:
    #
    # generate a self signed CA with the state library
    # offered fields in the value field:
    #   key, pub and cert
    #
    selfSignedCA: (( |cn,update|->_.keyCert(_.caSpec(cn),update) ))

    #
    # generate a key and cert signed by the given ca.
    # The ca is given by the state field generated by the 
    # selfSignedCA function.
    # offered fields in the value field:
    #   key, pub and cert
    #
    keyCertForCA: (( |certspec,ca,update|->_.keyCert({$caCert=ca.value.cert, $caPrivateKey=ca.value.key} certspec,update) ))

    #
    # generate a certificate state for a given cert spec
    # using the state libraray.
    # It must contain all the reuired key and cert fields.
    # offered fields in the value field:
    #   key, pub and cert
    #
    keyCert: (( |certspec,update|->utilities.state.standard(_.keyCertSpec(certspec),update) ))

    #######################
    # helper funcions
    #

    #
    # generate a spec for a certificate value to be
    # generated by the state library given a certificate spec
    #
    keyCertSpec: (( |certspec|->*_.templates.spec ))

    #
    # generate a certificate spec for a self signed ca
    # using the given common name
    #
    caSpec:      (( |cn|->*_.templates.ca ))


    #######################
    # helper templates
    #
    templates:
      #
      # specification for a self signed ca signing
      #
      ca:
        <<: (( &template ))
        commonName: (( cn ))
        isCA: true
        usage:
          - Signature
          - KeyEncipherment
  
      #
      # the value template used by the state library
      # to generate a new cert value containing
      # private key (key), public key (pub) and the
      # certificate (cert).
      # it requires a binding for input containing
      # a spec field with the certificate specification.
      # This specification is enriched with the newly
      # generated private key. This works for both.
      # self signed ca signing (provate key required)
      # or signing with a separate ca, the the required
      # public key is extracted from the given provate key.
      #
      value:
        <<: (( &template ))
        spec:
          <<: (( input.spec ))
          privateKey: (( state.key ))
        state:
          key: (( x509genkey(2048) ))
          pub: (( x509publickey(key) ))
          cert: (( x509cert(spec) ))
      #
      # the state specificatiom required by
      # the state library. It contains the input field
      # and the value template to generate a new value
      # if state has to be changed.
      # THis value template is just always the one declared above
      #
      spec:
        <<: (( &template ))
        input:
          spec: (( certspec ))
        value: (( _.templates.value ))

