# Copyright 2019 Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved. This file is licensed under the Apache Software License, v. 2 except as noted otherwise in the LICENSE file.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

############################################################################
# commands
############################################################################

################
# Resolve a shortcut for a given set of values
# The resolution is found as follows  (in given order)
# - the given value directly is identical to a possible choice
# - if the given value is a prefix of the possible choice, then the first
#   match is chosen.
# - if the given value is part of the possible choice, then the first
# - the given value
#
# $1:  the value to resolve
# $2+: the possible choices
################
CMDS_resolve_shortcut()
{
  if ! contains "$1" "${@:2}"; then
    for c in "${@:2}"; do
      if [[ "$c" =~ ^$1.* ]];  then
        echo "$c"
        return 0
      fi
    done
    for c in "${@:2}"; do
      if [[ "$c" =~ .*$1.* ]];  then
        echo "$c"
        return 0
      fi
    done
    for c in "${@:2}"; do
      if [[ "$c" =~ .*$(sed -e 's/\(.\)/\1.*/g'<<<"$1") ]];  then
        echo "$c"
        return 0
      fi
    done
  fi
  echo "$1"
}

################
#
# $1: the command value
# $2: the function prefix
# $3: possible command completions (space separated)
# $4+: command arguments
# options:
#   --invalid= function to call for invalid command
################
CMDS_execute_command()
{
  local errf=
  
  while [ $# -gt 0 -a "${1#--}" != "$1" ]; do 
    case "$1" in
      --invalid=*) errf="${1#--invalid=}";;
      *) Error "unknown option $1";;
    esac
    shift
  done

  local cmd="$(CMDS_resolve_shortcut "$1" $3)"
  if [ "$(type -t "$2$cmd")" == "function" ]; then
    $2$cmd "${@:4}"
  else
    if [ -n "$errf" ]; then
      $errf "$2" "$cmd" "${@:4}"
    else
      error "invalid command $cmd"
      return 1
    fi
  fi
}


CMDS_list_commands()
{
  QUIET=X
  declare -F | while read a b c d; do
    echo "$c"
  done | grep -e "^CMD_" | sed -e 's/^CMD_\(.*\)/\1/' | sort | while read a; do
    if ! contains "$a" "${CMDS[@]}"; then
      if [ "$(type -t "HELP_$a")" == "function" ]; then
        eval HELP_$a
      else
        echo "$a:"
      fi
    fi
  done
}

CMDS_help_command()
{
  if [ "$(type -t "HELP_$1")" == "function" ]; then
    HELP_$1 | CMDS_format_help
  else
    QUIET=X
    if [ "$(type -t "HELP_$1")" == "function" ]; then
      HELP_$1 | CMDS_format_help
    else
      echo "no help found for '$1'"
    fi
  fi
}

CMDS_format_help()
{
  local txt
  while IFS=":" read -r a b; do
    c="$(trim "$a")"
    if [ "$c" = "$a" ]; then
      printf -v txt "%-30s %s" "$a" "$b"
    else
      printf -v txt "  %-13s %s" "$c" "$b"
    fi
    if [ -z "$c" -o "$c" != "$a" ]; then
      found "  $txt"
    else
      info  "  $txt"
    fi
  done
}

