#!/usr/bin/env bash

VERSION=0.1

SOW="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; echo "$PWD" )"
SOWLIB="$SOW/lib"

get_version()
{
  echo "$nTOOL version $VERSION"
}

help()
{
  echo "$nTOOL - a tiny installer framework based on components and plugins"
  echo
  echo "$nTOOL [<options>] [<command>]"
  echo
  echo "options:"
  echo "  -a         complete the $nCOMPONENT set"
  echo "  -A         use all $nCOMPONENTS if no one is specified"
  echo "  -v         verbose mode"
  echo "  -t         trace mode"
  echo "  -D         debug mode"
  echo "  --version  show version"
  echo
  echo "commands:"
  echo "  info                    show info about current location"
  echo "  order {<components>}    show deployment order"
  echo "  show {<components>}     show info about components"
  echo "  deploy {<components>}   deploy components"
  echo "  delete {<components>}   delete deployment of components"
  echo "  add {<components>}      create a frame for a new component"
}

source "$SOWLIB/utils"
source "$SOWLIB/meta"
source "$SOWLIB/opts"

declare -A opts
declare -A params
params=( [a]=all [A]=All [v]=verbose [version]="" [dryrun]="" [x]=trace [D]=debug [p]="=$nPRODUCT" [terms]="=" [layout]="=" )
OPT_parse_options params opts "$@"
shift $(( _cnt - 1 ))

CFG_LAYOUT=garden
CFG_TERMS=garden

if [ -n "${opts[layout]}" ]; then
  CFG_LAYOUT="${opts[layout]}"
  CFG_TERMS=$CFG_LAYOUT
fi
if [ -n "${opts[terms]}" ]; then
  CFG_TERMS="${opts[terms]}"
fi

case "$1" in
  version) get_version
           exit 0;;
  help) help
        exit 0;;
esac

source "$SOWLIB/env"
source "$SOWLIB/cmd"
source "$SOWLIB/action"

jsonAdd()
{
  local new
  if [ $# -eq 3 ]; then
    new="\"$2\": $3"
  else
    new="$2"
  fi

  if [ -n "${!1}" ]; then
    new="${!1}, $new"
  else
    new="$new"
  fi
  eval $1="\"\$new\""
}

jsonAddString()
{
  if [ $# -eq 3 ]; then
    jsonAdd "$1" "$2" "\"$3\""
  else
    jsonAdd "$1" "\"$2\""
  fi
}

setupProductMeta()
{
  local d
  local product
  local rel

  local jprod

  rel="${1#$ROOT/}"
  product="${2:-${1##*/}}"
  if [ -n "${PRODUCTS["$product"]}" ]; then
    fail "$nPRODUCT $product ($rel) defined twice; ${PRODUCTS["$product"]}"
  fi
  PRODUCTS["$product"]="$rel"
  jsonAddString jprod dir "$rel"
  jsonAdd JMETAPRODS "$product" "{ $jprod }"

  verbose "found $nPRODUCT $product: $rel"
  while IFS= read -r line; do
    setupComponentMeta "$line"
  done < <(find "$1/$dCOMPONENTS" -name $fCOMPDEF)

  for d in "$1/$dPRODUCTS"/*; do
    if [ -d "$d" ]; then
      setupProductMeta "$d"
    fi
  done
}

setupComponentMeta()
{
  local jattr
  local jgraph
  local jdeps

  setComponent "${1%/*}"
  verbose "  $component: $reldir ($product)"
  getComponentJSON "$line"
  declare -A import_map
  getImports import_map COMPONENTJSON
  getValue active component.active COMPONENTJSON
  if [ -z "$active" ]; then
    active=true
  fi

  COMPONENTS["$component"]="$reldir"

  jsonAdd jattr active "$active"
  jsonAddString jattr dir "$reldir"
  jsonAddString jattr product "$product"

  for i in "${!import_map[@]}"; do
    i="$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'<<<"$i")"
    verbose "    $i: ${import_map["$i"]}"

    local jdep=""
    jsonAddString jdep label "$i"
    jsonAddString jdep component "${import_map["$i"]}"
    jsonAdd jdeps "{ $jdep }"
    jsonAddString jgraph "${import_map["$i"]}"
  done
  jsonAdd jattr imports "[ $jdeps ]"

  jsonAdd JMETACOMPS "$component" "{ $jattr }"
  if [ $active == true ]; then
    jsonAdd JMETAGRAPH "$component" "[ $jgraph ]"
  fi
}

setupLandscape()
{
  declare -Ag PRODUCTS COMPONENTS
  local JMETAGRAPH=
  local JMETACOMPS=
  local JMETAPRODS=
  local JMETA=

  setupProductMeta "$ROOTPRODUCTDIR" "$MAINPRODUCT"

  jsonAdd JMETA products   "{ $JMETAPRODS }"
  jsonAdd JMETA components "{ $JMETACOMPS }"
  jsonAdd JMETA graph      "{ $JMETAGRAPH }"

  METAJSON="{ $JMETA }"
  METAJSON="$(spiff merge --json "$SOW/helper/closure.yaml" - "$SOWLIB/templates/graph.yaml" <<<"$METAJSON")"
  echo "$METAJSON" | jq .>"$META"

  cycles=( )
  getJSONList cycles cycles METAJSON

  FAILED=
  if [ ${#cycles[@]} -ne 0 ]; then
     info "found dependency cycles:"
     for c in "${cycles[@]}"; do
       cycle=( )
       getValueList cycle "" c
       echo "--> ${cycle[@]}"
     done
     FAILED=X
  fi

  msg="found missing dependencies:"
  for c in "${!COMPONENTS[@]}"; do
    missing=( )
    getValueList missing "closures[\"$c\"].missing" METAJSON
    if [ ${#missing[@]} -ne 0 ]; then
      if [ -n "$msg" ]; then
        echo "$msg"
        msg=
      fi
      echo "--> $c: ${missing[@]}"
      FAILED=X
    fi
  done

  if [ -n "$FAILED" ]; then
    fail "aborted due to dependency problems"
  fi

}

###########################################################################
# commands
###########################################################################

# missing command handler
# $1: prefix of missing command function
# $2: command name
# $3+: command arguments
handle_action_command()
{
  if [ "$(type -t "$1$2")" == "function" ]; then
    $1$2 "${@:3}"
  else
    CMD_deploy "${@:2}"
  fi
}



showComponent()
{
  local c="$1"
  local order
  local comp
  local active
  local prod
  local imps
  local label
  local dep
  local dir
  local i

  info " - $c: ${COMPONENTS[$c]}"
  getComponentMeta comp "$c"
  getComponentMetaProduct prod comp
  getMetaProductDir dir "$prod"
  info "     $nPRODUCT: $prod ($dir)"
  getValue active active comp
  info "     active: $active"
  info "     dependencies:"
  getJSONList imps "imports" comp
  for i in "${imps[@]}"; do
    getValue label label i
    getValue dep component i
    info "     - $label: $dep"
  done
  getJSON comp "closures[\"$c\"]" METAJSON
  getValueList order "order" comp
  info "     $nTOOL order:"
  for i in "${order[@]}"; do
    info "     - $i"
  done
  ( # should be part of the landscape meta data, later on
    CURRENT="$ROOT/${COMPONENTS[$c]}"
    setComponent "$CURRENT"
    getComponentJSON "$CURRENT/$fCOMPDEF"
    PRODUCTDIR="$productdir"

    declare -a slist
    # evaluate additional stubs
    _get_value_list slist stubs COMPONENTJSON
    if [ ${#slist[@]} -ne 0 ]; then
      info "     configured deployment stubs:"
      for i in "${slist[@]}"; do
        local stub
        stub="$(lookupStub "$i")"
        if [ -z "$stub" ]; then
          info "     - $i (not found)"
        else
          info "     - $i (${stub#$ROOT/})"
        fi
      done
    fi
  )
}

CMD_help()
{
  help
  exit 0
}

CMD_version()
{
  get_version
  exit 0
}

CMD_info()
{
  local order
  local comp
  local active
  local prod
  local imps
  local label
  local dep
  local i

  info "$nLANDSCAPE" "$ROOT"
  if [ ${opts[all]+set} ]; then
    info "$nCOMPONENTS:"
    for c in "${!COMPONENTS[@]}"; do
      showComponent "$c"
    done
    echo
    order=( )
    getValueList order order METAJSON
    info "$nTOOL order: ${order[@]}"
  else
    if [ -n "$CURRENT" ]; then
      showComponent "$COMPONENT"
    else
      if [ -n "$PRODUCTDIR" ]; then
        info "$nPRODUCT" "$PRODUCT (${PRODUCTDIR#$ROOT/})"
      fi
    fi
  fi
}

CMD_order() {
  execClosure _CMD_order "$@"
}

_CMD_order()
{
  for c in "${@}"; do
    if ! contains "$c" "${order[@]}"; then
      fail "$nCOMPONENT $c not found in ${nTOOL}ing order"
    fi
  done
  for c in "${order[@]}"; do
    if contains "$c" "${comps[@]}"; then
      echo "$c"
    fi
  done
}

CMD_show()
{
  execClosure _CMD_show "$@"
}

_CMD_show()
{
  local comp
  local active
  local label
  local dep

  FAILED=
   for c in "$@"; do
     showComponent "$c"
   done
}

CMD_deploy()
{
  execClosure _CMD_deploy "$@"
}

_CMD_deploy()
{
  for c in "${@}"; do
    if ! contains "$c" "${order[@]}"; then
      fail "$nCOMPONENT $c not found in ${nTOOL}ing order"
    fi
  done
  for c in "${order[@]}"; do
    if contains "$c" "${comps[@]}"; then
      echo "${nTOOL}ing $nCOMPONENT $c"
      ACTION_execute deploy "$c"
    fi
  done
}

CMD_delete()
{
  execClosure _CMD_delete "$@"
}

_CMD_delete()
{
  for c in "${@}"; do
    if ! contains "$c" "${order[@]}"; then
      fail "$nCOMPONENT $c not found in ${nTOOL}ing order"
    fi
  done
  for c in "${order[@]}"; do
    if contains "$c" "${comps[@]}"; then
      echo "${nTOOL}ing $nCOMPONENT $c"
      ACTION_execute delete "$c"
    fi
  done
}

execClosure()
{
  local cmd="$1"
  local order=( )
  local tmp=( )
  local comps=( )
  local o
  shift

  resolveComponents "$@"

  getValueList tmp order METAJSON
  if [ "$cmd" == _CMD_delete ]; then
    for o in "${tmp[@]}"; do
      order=( "$o" "${order[@]}" )
    done
  else
    order=( "${tmp[@]}" )
  fi

  if [ ${#comps[@]} -eq 0 ]; then
    if [ ${opts[All]+set} ]; then
       comps=( "${order[@]}" )
    else
      if [ -z "$COMPONENT" ]; then
        fail "not in a $nCOMPONENT"
      else
        comps=( "$COMPONENT" )
      fi
    fi
  fi

  local cnt=0
  if [ ${opts[all]+set} ]; then
     tmp=( )
     for o in "${order[@]}"; do
       tmp=( "${tmp[@]}" "$o" )
       if contains "$o" "${comps[@]}"; then
         (( cnt+=1 ))
         if [ $cnt -eq ${#comps[@]} ]; then
           break
         fi
       fi
     done
     comps=( "${tmp[@]}" )
  fi

  $cmd "${comps[@]}"
}


resolveComponents()
{
  comps=( )
  for s in "$@"; do
     c="$(CMDS_resolve_shortcut "$s" "${!COMPONENTS[@]}")"
     if [ -z "$c" ]; then
       fail "unknown $nCOMPONENT $s"
     else
       if ! contains "$c" "${comps[@]}"; then
         comps=( "${comps[@]}" "$c" )
       fi
     fi
  done
}

CMD_add()
{
  local productdir="$PRODUCTDIR"
  local product="$PRODUCT"
  if [ -n "${opts[$nPRODUCT]}" ]; then
    product="$(CMDS_resolve_shortcut "${opts[$nPRODUCT]}" "${!PRODUCTS[@]}")"
    productdir="${PRODUCTS[$product]}"
    if [ -z "$productdir" ]; then
      fail "unknown $nPRODUCT ${opts[$nPRODUCT]}"
    fi
    productdir="$ROOT/$productdir"
  fi
  if [ -z "$productdir" ]; then
    fail "please select a $nPRODUCT"
  fi
  if [ $# -eq 0 ]; then
      fail "component name required"
  fi

  for c in "$@"; do
    COMPDIR="$productdir/$dCOMPONENTS/$c"

    if [ -n "${COMPONENTS["$c"]}" ]; then
        fail "$nCOMPONENT $c already exists"
    fi
    if [ -d "$COMPDIR" ]; then
        fail "folder for $nCOMPONENT $c already exists"
    fi

    info "creating $nCOMPONENT $c in $nPRODUCT $product"

    mkdir -p "$COMPDIR/lib"
    cat <<EOF >"$COMPDIR/lib/action"
#
# remove this file if no dediyted deploy or delete code
# is required
#
deploy()
{
  true
}

delete()
{
  true
}
EOF
    chmod a+x "$COMPDIR/lib/action"

    cat <<EOF > "$COMPDIR/component.yaml"
---
component:
  imports: []

  stubs: []
EOF
    cat <<EOF > "$COMPDIR/deployment.yaml"
---
imports: (( &temporary ))

plugins:
EOF
    echo "---" > "$COMPDIR/export.yaml"
    echo "state:" > "$COMPDIR/state.yaml"
  done
}

###########################################################################
# main
###########################################################################


if [ ${opts[version]+set} ]; then
  get_version
  exit 0
fi

if [ ${opts[verbose]+set} ]; then
  VERBOSE=X
else
  VERBOSE=
fi

if [ ${opts[debug]+set} ]; then
  DEBUG=X
else
  DEBUG=
fi

if [ ${opts[dryrun]+set} ]; then
  DRYRUN=X
else
  DRYRUN=
fi

export DRYRUN
export DEBUG
export VERBOSE

CMDS=( deploy delete info show help version add )
cmd="$(CMDS_resolve_shortcut "$1" "${CMDS[@]}")"

verbose "$nLANDSCAPE = $ROOT"
verbose "$nLANDSCAPE $nPRODUCT = $ROOTPRODUCTDIR"
if [ -n "$PRODUCT" ]; then
  verbose "$nPRODUCT = $PRODUCT"
  if [ -n "$COMPONENT" ]; then
    verbose "$nCOMPONENT = $COMPONENT"
    verbose "$nCOMPONENT dir = $CURRENT ($CURRENTRELDIR)"
  fi
fi

TRACE=
if [ ${opts[trace]+set} ]; then
  TRACE=X
  set -x
fi
export TRACE

setupLandscape

CMDS_execute_command --invalid=handle_action_command "$cmd" CMD_ "${CMDS[*]}" "${@:2}"

